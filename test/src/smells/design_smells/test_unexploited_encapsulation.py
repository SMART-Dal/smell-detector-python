import ast
import logging
from unittest.mock import create_autospec

import pytest

from src.smells.design_smells import UnexploitedEncapsulationDetector
from src.sourcemodel.sm_class import SMClass
from src.sourcemodel.sm_method import SMMethod
from src.sourcemodel.sm_module import SMModule


@pytest.fixture
def detector():
    return UnexploitedEncapsulationDetector()


@pytest.fixture
def simple_method():
    method = create_autospec(SMMethod, instance=True)
    method.name = "simple_method"
    method.start_line = 1
    method.ast_node = ast.parse("x = 1").body[0]  # A simple assignment, no type checking
    return method


@pytest.fixture
def type_checking_method():
    method = create_autospec(SMMethod, instance=True)
    method.name = "type_checking_method"
    method.start_line = 1
    method.ast_node = ast.parse("if isinstance(x, int): pass").body[0]  # Simulate type checking
    return method


@pytest.fixture
def simple_class(simple_method):
    py_class = create_autospec(SMClass, instance=True)
    py_class.name = "SimpleClass"
    py_class.methods = [simple_method]
    py_class.start_line = 1
    return py_class


@pytest.fixture
def class_with_type_check(type_checking_method):
    py_class = create_autospec(SMClass, instance=True)
    py_class.name = "ClassWithTypeCheck"
    py_class.methods = [type_checking_method]
    py_class.start_line = 1
    return py_class


@pytest.fixture
def mock_module(simple_class, class_with_type_check):
    module = create_autospec(SMModule, instance=True)
    module.name = "TestModule"
    module.classes = [simple_class]
    module.functions = []  # No global functions for now
    return module


@pytest.fixture
def complex_method_with_type_checks():
    method = create_autospec(SMMethod, instance=True)
    method.name = "complex_method"
    method.start_line = 1
    method.ast_node = ast.parse("""
if isinstance(x, int):
    if isinstance(y, str):
        pass
elif type(z) is float:
    pass
else:
    pass
""").body[0]
    return method


def test_no_explicit_type_checks(detector, mock_module, simple_class):
    smells = detector._detect_smells(mock_module, {})
    assert len(smells) == 0, "Should not detect smells for methods without explicit type checks."


def test_explicit_type_checks_in_method(detector, mock_module, class_with_type_check):
    mock_module.classes = [class_with_type_check]
    smells = detector._detect_smells(mock_module, {})
    assert len(smells) == 1, "Should detect a smell for methods with explicit type checks."




def test_explicit_type_checks_in_function(detector, mock_module, type_checking_method):
    mock_module.functions = [type_checking_method]
    mock_module.classes = []  # No classes, only functions
    smells = detector._detect_smells(mock_module, {})
    assert len(smells) == 1, "Should detect a smell for functions with explicit type checks."


def test_multiple_entities_with_type_checks(detector, mock_module, class_with_type_check, type_checking_method,
                                            simple_class):
    mock_module.classes = [class_with_type_check, simple_class]
    mock_module.functions = [type_checking_method]
    smells = detector._detect_smells(mock_module, {})
    assert len(smells) == 2, "Should detect smells for both classes and functions with explicit type checks."


def test_nested_explicit_type_checks(detector, mock_module, complex_method_with_type_checks):
    complex_class = create_autospec(SMClass, instance=True)
    complex_class.name = "ComplexClass"
    complex_class.methods = [complex_method_with_type_checks]
    complex_class.start_line = 1
    mock_module.classes = [complex_class]
    smells = detector._detect_smells(mock_module, {})
    assert len(smells) == 1, "Should detect smells for methods with nested explicit type checks."


def test_no_fields_accessed_by_methods(detector, mock_module, simple_class, simple_method):
    simple_class.methods = [simple_method]
    simple_class.class_fields = {}
    simple_class.instance_fields = {}
    mock_module.classes = [simple_class]
    smells = detector._detect_smells(mock_module, {})
    assert len(smells) == 0, "Should not detect smells for classes with no field accesses."


def test_private_field_access(detector, mock_module, class_with_type_check):
    # Assume the class has a private field and a method accessing it
    class_with_type_check.class_fields = {'_privateField': 'private'}
    smells = detector._detect_smells(mock_module, {})
    assert len(smells) == 0, "Should not detect smells for properly encapsulated private fields."


def test_error_handling(detector, mock_module, caplog):
    mock_module.classes = Exception("Test Exception")
    with caplog.at_level(logging.ERROR):
        detector._detect_smells(mock_module, {})
        assert "Error detecting Unexploited Encapsulation smells" in caplog.text, \
            "Should log an error message when an exception occurs."
