import ast
import logging

from ..smell_detector import DesignSmellDetector


class UnexploitedEncapsulationDetector(DesignSmellDetector):
    def _detect_smells(self, module, config):
        smells = []
        try:
            entities = [(method, py_class) for py_class in module.classes for method in py_class.methods] + \
                       [(function, None) for function in module.functions]

            for entity, parent in entities:
                if self._has_explicit_type_checks(entity.ast_node):
                    detail = self._create_detail(entity, parent)
                    smell = self._create_smell(module.name, parent or entity, detail, entity.start_line)
                    if smell:
                        print(smell)
                        smells.append(smell)

            logging.info(f"Detected {len(smells)} Unexploited Encapsulation smells in {module.name}")
        except Exception as error:
            logging.error(f"Error detecting Unexploited Encapsulation smells in module {module.name}: {error}",
                          exc_info=True)
        return smells

    def _has_explicit_type_checks(self, node):
        if isinstance(node, ast.Call) and \
                ((isinstance(node.func, ast.Name) and node.func.id in ['isinstance', 'type']) or
                 (isinstance(node.func, ast.Attribute) and node.func.attr in ['isinstance', 'type'])):
            return True
        for child in ast.iter_child_nodes(node):
            if self._has_explicit_type_checks(child):
                return True
        return False

    @staticmethod
    def _create_detail(entity, parent):
        if parent:
            return f"Method '{entity.name}' in class '{parent.name}' may not be exploiting encapsulation properly by using explicit type checks."
        else:
            return f"Function '{entity.name}' may not be exploiting encapsulation properly by using explicit type checks."
